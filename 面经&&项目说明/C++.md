# C/C++

## 1 C方向

## 2 C++基础

### 2.1 栈和堆

#### 2.1.1 栈

栈是一种用于存储局部变量、函数参数、函数局部变量、函数返回地址和函数调用的上下文信息的内存分配方式。

特点：

- 栈上分配的内存由编译器自动管理，无需手动释放。
- 栈上的内存分配和释放速度较快，因为它是通过调整栈顶指针来实现的。
- 栈空间通常有限，因此分配大型对象或大量对象可能导致栈溢出（stack overflow）。
- 栈上的变量的生命周期与其所在的作用域相对应，当变量超出作用域时，其内存会自动释放。

#### 2.1.2 堆

堆是一种用于存储程序运行时需要动态分配的数据的内存分配方式。

特点：

- 堆上分配的内存需要手动申请和释放，程序员负责管理其生命周期。
- 堆上的内存分配和释放速度较慢，因为它是通过在堆中搜索合适的空闲内存块来实现的。
- 堆空间通常比栈空间大得多，因此适合存储大型对象或大量对象。
- 堆上的内存不会自动释放，直到程序员显式调用`delete`操作符来释放内存，否则可能导致内存泄漏。

#### 2.1.3 栈和堆 如何选择

- 如果变量的生命周期在编译时已知，并且占用的内存量不大，则通常选择在栈上分配内存。
- 如果变量的生命周期不确定，或者需要分配大量内存，或者需要在不同的作用域中共享数据，则通常选择在堆上分配内存。

#### 2.1.4 栈溢出与堆溢出

- 栈溢出：当栈空间不足以容纳新的栈帧时，会发生栈溢出。这通常是由于递归调用层数过深或者在栈上分配过大的局部变量导致的。栈溢出会导致程序崩溃，并可能引发严重的安全问题。
- 堆溢出：堆溢出通常发生在动态分配内存时，如果程序不正确地管理堆内存，可能会导致内存泄漏或者越界访问。堆溢出同样会导致程序崩溃，并可能损坏程序的稳定性和可靠性。

### 2.2 static

1. 静态变量（Static Variables）
静态变量是指生命周期贯穿整个程序运行期间的变量，它们在内存中只有一份拷贝，并且通常存储在数据段（data segment）中。静态变量可以是全局的，也可以是局部的。

- **全局静态变量**：全局静态变量在整个程序运行期间保持不变，作用域限制在声明它的文件内部。

- **局部静态变量**：局部静态变量在程序运行期间保持不变，但其作用域限制在声明它的函数内部。局部静态变量在第一次进入函数时被初始化，并且在该次函数调用结束后仍保留其值，直到该函数不再被执行或者程序结束。

2. 静态函数（Static Functions）
静态函数是指仅在声明它的文件内部可见的函数。静态函数不能被其他文件中的函数调用，它们的作用域被限制在声明它的文件内部，对于其它源文件是屏蔽的。

3. 静态成员变量（Static Member Variables）
静态成员变量属于类，而不是类的实例。它们在内存中只有一份拷贝，被所有类的对象所共享。静态数据成员在类内声明，在类外定义时进行初始化，静态成员不能通过类构造函数进行初始化。

静态成员的名字在类的作用域中，可以避免与其他类的成员或全局对象名字冲突。静态成员可以实施封装，可以是私有成员，而全局对象不可以。

4. 静态成员函数（Static Member Functions）
静态成员函数属于类，而不是类的实例。静态成员函数的作用是为了访问静态数据成员。静态成员函数与非静态成员函数的根本区别是非静态成员函数有this指针，而静态成员函数没有this指针，因此静态成员函数不能访问本类中的非静态成员，非静态成员函数可以调用静态成员函数，静态成员函数不能调用非静态成员函数

### 2.3 从源文件到目标文件

1. 预处理（Preprocessing）
在编译之前，源文件会经过预处理器的处理。预处理器会处理以 # 开头的预处理指令，比如 #include、#define、#ifdef 等，并将其替换为相应的文本。预处理器的输出通常是一个临时的扩展名为 .i 的中间文件。

- 移除注释：删除源文件中的注释部分，以减少代码量。
- 处理 #include 指令：将头文件的内容插入到源文件中，以便后续编译阶段使用。
- 处理 #define 指令：替换源文件中的宏定义为其对应的文本内容。
- 处理条件编译指令：根据条件编译指令的条件，选择性地包含或排除特定的代码块。

2. 编译（Compilation）
预处理完成后，编译器会将预处理后的源文件转换为汇编代码（Assembly Code）。编译器会将源代码转换为中间代码，这些中间代码通常是与特定硬件平台无关的。编译器的输出通常是一个汇编语言文件，其扩展名为 .s。

- 词法分析：将源代码分解成词法单元，如关键字、标识符、运算符等。
- 语法分析：根据编程语言的语法规则，将词法单元组合成语法树。
- 语义分析：检查代码中是否有语义错误，如类型不匹配、未声明的变量等。
- 生成中间代码：将源代码转换为与特定硬件平台无关的中间代码。

3. 汇编（Assembly）
汇编器（Assembler）将汇编语言代码转换为机器码（Machine Code）。汇编器将汇编代码翻译成二进制指令，这些指令是特定硬件平台上的可执行指令。汇编器的输出通常是一个目标文件，其扩展名为 .o 或 .obj。

- 将中间代码转换为特定硬件平台的汇编代码。
- 为变量和函数生成符号表。
- 为汇编指令生成机器指令，并指定地址。
- 生成目标文件，其中包含了机器代码、符号表和其他元数据。

4. 链接（Linking）
链接器（Linker）将多个目标文件以及库文件（如果有的话）链接到一起，生成最终的可执行文件。链接器解析目标文件中的符号引用，将其与其他目标文件或库文件中的符号定义进行关联，生成最终的可执行文件。链接器的输出通常是一个可执行文件，其扩展名为 .exe（Windows）或者没有扩展名（Unix/Linux）。

- 解析符号引用：查找目标文件中引用的函数或变量在其他目标文件中的定义。
- 符号解析：将目标文件中的符号引用与其他目标文件或库文件中的符号定义进行关联。
- 地址重定位：根据链接器指定的地址空间，调整目标文件中的地址。
- 生成可执行文件：将所有目标文件和库文件链接在一起，生成最终的可执行文件。

### 2.4 静态库和动态库

在C++中，静态库（Static Library）和动态库（Dynamic Library）是两种常见的代码重用和共享方式.

**静态库（Static Library）**
静态库是一组已编译的目标文件的集合，它们被打包成一个单独的文件（通常是`.lib`或`.a`文件），其中包含了程序所需的所有函数和数据。静态库的特点包括：

- 静态库在编译时链接到目标程序中，因此在程序运行前会被完全复制到可执行文件中。
- 静态库的使用方式是将库的函数和数据拷贝到程序中，因此程序在运行时不需要额外的库文件支持。
- 静态库适合用于小型项目或者需要将所有依赖项打包到一个独立的可执行文件中的项目。

**动态库（Dynamic Library）**
动态库是一组被编译成共享对象文件（`.dll`、`.so`或`.dylib`文件），它们在程序运行时加载到内存中，并可以在多个程序之间共享。动态库的特点包括：

- 动态库在运行时动态加载到内存中，因此可以被多个程序共享，并且可以在不同的系统上运行。
- 动态库的使用方式是在程序运行时动态链接到目标程序中，因此程序运行前不需要将库文件复制到可执行文件中。
- 动态库适合用于大型项目或者需要在多个程序之间共享代码和数据的项目。

**使用场景**

- 静态库的使用场景

1. 当程序的依赖关系相对简单，且需要将所有依赖项打包到一个独立的可执行文件中时，可以使用静态库。
2. 当需要在一个程序中嵌入某些特定的功能，并且不希望程序依赖外部的库文件时，可以使用静态库。

- 动态库的使用场景

1. 当程序需要在运行时动态加载一些功能模块，或者需要在多个程序之间共享代码和数据时，可以使用动态库。
2. 当程序需要在不同的操作系统上运行，并且需要适配不同的硬件环境时，可以使用动态库。

**区别**

- 链接方式：静态库在编译时静态链接到目标程序中，而动态库在程序运行时动态链接到目标程序中。
- 加载方式：静态库在程序运行前被完全复制到可执行文件中，而动态库在程序运行时动态加载到内存中。
- 可执行文件大小：由于静态库会完全复制到可执行文件中，因此可执行文件大小较大；而动态库不会被复制到可执行文件中，因此可执行文件大小较小。
- 更新和维护：由于动态库可以被多个程序共享，并且可以在运行时动态更新，因此更新和维护动态库相对更加灵活。

### 2.5

### 2.6

### 2.7

## 3 类方向

### 3.1 面向对象编程（OOP）的四大基本原则：抽象、继承、多态、封装

#### 3.1.1 抽象（Abstraction）

抽象是将复杂的现实世界中的实体和其关系简化为程序中的类和对象的过程。通过抽象，程序员可以将现实世界中的概念映射到代码中，从而更轻松地理解和管理代码。抽象包括数据抽象（将数据和操作封装为类）和行为抽象（将对象的行为和特征抽象为类的方法和属性）两个方面。

#### 3.1.2 继承（Inheritance）

继承是指一个类（称为子类或派生类）可以从另一个类（称为父类或基类）中继承属性和行为。通过继承，子类可以直接使用父类的成员，而不需要重新实现相同的功能。这种机制促进了代码重用和层次化设计，并支持代码的扩展和修改。子类可以继承父类的公有成员和保护成员，但不继承私有成员。

**注意事项**

- **访问控制**：继承可以实现类与类之间的访问控制。公有继承表示子类可以访问父类的公有成员，保护继承表示子类可以访问父类的公有和保护成员，私有继承表示子类无法访问父类的任何成员。
- **构造函数和析构函数的继承**：子类继承父类的构造函数和析构函数。在创建子类对象时，会先调用父类的构造函数，然后再调用子类的构造函数；在销毁子类对象时，会先调用子类的析构函数，然后再调用父类的析构函数。
- **覆盖（Override）和隐藏（Hide）**：子类可以重写父类的成员函数，以提供特定于子类的实现。如果子类中的成员函数与父类中的成员函数同名且参数列表相同，则子类的函数会覆盖父类的函数。如果子类中定义了与父类同名但参数列表不同的函数，则父类的函数会被隐藏，不会触发多态性。
- **多态性**：继承是实现多态性的重要机制之一。通过在父类中声明虚函数，并在子类中重写这些函数，可以实现运行时多态性。在程序运行时，可以根据对象的实际类型来选择调用相应的函数版本，从而实现多态性。
- **设计原则**：合理使用继承可以提高代码的重用性和可维护性，但过度使用继承可能导致代码复杂性增加，不利于代码的理解和维护。在设计类之间的继承关系时，应遵循“is-a”关系，即子类应该是父类的一种特殊类型。

#### 3.1.3 多态（Polymorphism）

多态是指相同的操作在不同的对象上可以产生不同的行为。多态性使得程序能够根据对象的实际类型来选择正确的操作，从而实现更灵活和可扩展的代码。在C++中，多态性主要通过虚函数和函数重写来实现，允许在运行时动态地选择要调用的函数版本。

##### 3.1.3.1 虚函数（Virtual Function）

1. 虚函数的基本概念
虚函数是在基类中声明的函数，在派生类中可以被重写（Override）。通过将函数声明为虚函数，可以在运行时根据对象的实际类型来确定调用的函数版本。即虚函数允许在基类和派生类之间实现动态绑定，从而在运行时确定调用的函数版本。

2. 虚函数的工作原理
当基类的指针或引用指向派生类对象时，通过调用虚函数来实现多态性。在运行时，程序会根据指针或引用所指向的对象的实际类型，查找该对象所属类的虚函数表（vtable），然后根据表中的虚函数地址来调用相应的函数。这样就实现了动态绑定，即在运行时确定调用的函数版本。

3. 虚函数的注意事项：

- 虚函数通常在基类中声明为虚函数，而在派生类中进行重写。如果在派生类中不重写虚函数，则会继承基类中的虚函数实现。
- 虚函数可以被覆盖（Override），但不能被重载（Overload）。如果在派生类中定义了一个与基类中的虚函数同名但参数列表不同的函数，不会触发多态性，而是隐藏基类的虚函数。
- 虚函数可以是纯虚函数（Pure Virtual Function），即在基类中只声明而不定义。如果一个类包含至少一个纯虚函数，则该类被称为抽象类，无法直接实例化，而只能作为基类来派生其他类。

##### 3.1.3.2 函数重写（Function Overriding）

1. 函数重写的基本概念
函数重写是指派生类中重新定义（Override）基类中的虚函数，以提供特定于派生类的实现。函数重写是多态性的一种形式，允许在运行时动态地选择要调用的函数版本。

在C++中，通过在派生类中使用与基类中虚函数相同的函数名、参数列表和返回类型，可以重写基类中的虚函数。重写时，函数必须使用`override`关键字进行标记，以确保它确实是对基类中虚函数的重写。

2. 函数重写的注意事项：

- 函数重写必须在派生类中使用与基类中虚函数相同的函数签名（即函数名、参数列表和返回类型），否则不会触发多态性。
- 重写的函数可以具有与基类中虚函数不同的访问修饰符（如 public、protected、private），但不能比基类中的虚函数访问修饰符更严格。
- 在派生类中可以选择是否重写基类中的虚函数，如果不重写，则继承基类中的虚函数实现。

#### 3.1.4 封装（Encapsulation）

封装是将数据和操作封装在类的内部，同时隐藏其具体实现细节的过程。通过封装，对象的内部状态和行为对外部是不可见的，外部只能通过公有的接口来与对象进行交互。这种机制提高了代码的安全性和可维护性，并支持代码的模块化和复用。

### 3.2

### 3.3

### 3.4

## 4 C++新特性

## 5 多线程编程和并发编程

### 5.1 死锁

死锁是多线程编程中常见的问题，它发生在两个或多个线程互相等待对方持有的资源而无法继续执行的情况下。预防和处理死锁的方法有多种，以下是一些常用的方法：

**预防死锁的方法：**

1. 避免使用多个锁：尽量减少代码中的锁的数量，使用更细粒度的锁或者使用一种更高级别的同步机制来避免死锁的发生。
2. 按照固定的顺序获取锁：为了避免循环等待的情况，可以规定获取锁的顺序，并且保持所有线程都按照相同的顺序获取锁。
3. 避免持有锁的同时等待其他锁：在持有一个锁的情况下，避免等待其他锁。如果需要等待其他锁，则先释放已经持有的锁，再等待其他锁。
4. 设置超时时间：在获取锁的过程中设置超时时间，如果超过一定时间仍然无法获取到锁，则放弃当前操作，释放已经获取的锁，并且进行重试或者放弃。

**处理死锁的方法：**

1. 检测和恢复：实现死锁检测机制，当检测到死锁发生时，进行资源回收或者终止某些线程，以解除死锁。
2. 强制终止：当检测到死锁发生时，强制终止某些线程，以解除死锁。这种方法可能会导致部分操作的丢失，因此需要谨慎使用。
3. 资源预留：线程在获取资源时，一次性获取所有需要的资源，而不是逐个获取。如果无法一次性获取所有资源，则释放已经获取的资源，等待其他线程释放资源后重新尝试获取。
4. 定时中断：使用定时中断机制，当检测到死锁发生时，中断所有线程，并尝试解除死锁。这种方法可以避免强制终止线程导致的数据丢失问题。
